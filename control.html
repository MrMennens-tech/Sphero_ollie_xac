<!DOCTYPE html>
<html lang="nl" class="h-full bg-gray-900 text-white">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sphero Ollie Web + Gamepad Controller</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.1/nipplejs.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            touch-action: none;
        }
        #joystick-zone {
            position: relative;
            width: 250px;
            height: 250px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.1);
            border: 2px dashed rgba(255, 255, 255, 0.3);
        }
        .status-dot {
            height: 12px;
            width: 12px;
            border-radius: 50%;
            display: inline-block;
            transition: background-color 0.3s ease;
        }
        .status-dot.disconnected { background-color: #ef4444; } /* red-500 */
        .status-dot.connected { background-color: #22c55e; } /* green-500 */
        .status-dot.connecting { background-color: #eab308; } /* yellow-500 */
    </style>
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
</head>
<body class="h-full flex flex-col items-center justify-center p-4 space-y-4">

    <div class="text-center">
        <h1 class="text-4xl font-bold">Sphero Ollie Controller</h1>
        <p class="text-gray-400 mt-2">Bestuur je Ollie via het scherm of met een USB Gamepad.</p>
    </div>

    <!-- Status Indicators -->
    <div class="flex items-center space-x-8 bg-gray-800 p-4 rounded-lg">
        <div class="flex items-center space-x-3">
            <span id="ollie-status-dot" class="status-dot disconnected"></span>
            <span id="ollie-status" class="font-medium">Ollie: Niet verbonden</span>
        </div>
        <div class="flex items-center space-x-3">
            <span id="gamepad-status-dot" class="status-dot disconnected"></span>
            <span id="gamepad-status" class="font-medium">Gamepad: Niet verbonden</span>
        </div>
    </div>

    <!-- Main Controls -->
    <div class="flex flex-col md:flex-row items-center justify-center gap-8 mt-4">
        <!-- On-screen Joystick -->
        <div class="flex flex-col items-center space-y-4">
             <h2 class="text-lg font-semibold">Scherm-joystick</h2>
            <div id="joystick-zone"></div>
        </div>

        <!-- Connection and other Controls -->
        <div class="flex flex-col items-center space-y-4">
            <button id="connect-button" class="w-48 bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg transition-transform transform hover:scale-105">
                Verbind met Ollie
            </button>
            <div class="flex flex-col items-center space-y-2">
                <label for="color-picker" class="font-semibold">Kies een kleur</label>
                <input type="color" id="color-picker" value="#00BFFF" class="w-24 h-12 p-1 bg-gray-800 rounded-lg cursor-pointer">
            </div>
             <div id="speed-indicator" class="w-48 text-center bg-gray-700 p-2 rounded-lg font-medium">Max Snelheid: 100%</div>
             <div id="mode-indicator" class="w-48 text-center bg-indigo-600 p-2 rounded-lg font-medium">Modus: Normaal</div>
        </div>
    </div>
    
    <!-- Instructions -->
    <div class="max-w-xl text-center text-gray-400 text-sm p-4 bg-gray-800 rounded-lg mt-4">
        <h3 class="font-bold text-white mb-2">Gamepad Besturing</h3>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-x-8">
            <div>
                <p class="font-bold text-white">Normale Modus:</p>
                <p>X1 (A): LED Rood</p>
                <p>X2 (B): LED Blauw</p>
                <p>X3 (X): LED Groen</p>
                <p>X4 (Y): LED Geel</p>
                <p>X5 (LB): Snelheid omlaag</p>
                <p>X6 (RB): Snelheid omhoog</p>
            </div>
            <div>
                <p class="font-bold text-white">Trick Modus:</p>
                <p>X1 (A): Spin links</p>
                <p>X2 (B): Flip vooruit</p>
                <p>X3 (X): Flip achteruit</p>
                <p>X4 (Y): Spin rechts</p>
                <p class="mt-2"><span class="font-bold text-white">Wissel Modus:</span> Druk X5 (LB) + X6 (RB) tegelijk in.</p>
            </div>
        </div>
    </div>


    <script>
        const connectButton = document.getElementById('connect-button');
        const colorPicker = document.getElementById('color-picker');
        const joystickZone = document.getElementById('joystick-zone');
        const ollieStatus = document.getElementById('ollie-status');
        const ollieStatusDot = document.getElementById('ollie-status-dot');
        const gamepadStatus = document.getElementById('gamepad-status');
        const gamepadStatusDot = document.getElementById('gamepad-status-dot');
        const speedIndicator = document.getElementById('speed-indicator');
        const modeIndicator = document.getElementById('mode-indicator');

        // Based on https://github.com/binomed/sphero_ollie-web-bluetooth/blob/master/lib.js
        class Ollie {
            // ... (Ollie class from previous version, with one addition)
            constructor() {
                this.device = null;
                this.services = {};
                this.characteristics = {};
                this.sequence = 0;
                this.currentHeading = 0; // Keep track of heading
            }

            async connect() {
                try {
                    console.log('Requesting Bluetooth device...');
                    updateOllieStatus('Zoeken...', 'connecting');
                    this.device = await navigator.bluetooth.requestDevice({
                        filters: [
                            { namePrefix: 'Ollie' },
                            { services: ['22bb746f-2bb0-7554-2d6f-726568705327'] } // Main service UUID
                        ],
                        optionalServices: [
                            '22bb746f-2bb0-7554-2d6f-726568705327', 
                            '22bb746f-2bbf-7554-2d6f-726568705327'
                        ]
                    });
                    
                    this.device.addEventListener('gattserverdisconnected', () => this.onDisconnected());
                    
                    console.log('Connecting to GATT Server...');
                    updateOllieStatus('Verbinden...', 'connecting');
                    const server = await this.device.gatt.connect();

                    console.log('Getting services...');
                    const services = await server.getPrimaryServices();

                    for (const service of services) {
                        this.services[service.uuid] = service;
                        const characteristics = await service.getCharacteristics();
                        for (const characteristic of characteristics) {
                            this.characteristics[characteristic.uuid] = characteristic;
                        }
                    }

                    console.log('Ollie connected');
                    updateOllieStatus('Verbonden', 'connected');
                    await this.init();
                    return true;
                } catch (error) {
                    console.error('Connection failed:', error);
                    updateOllieStatus('Verbinding mislukt', 'disconnected');
                    return false;
                }
            }

            onDisconnected() {
                console.log('Ollie disconnected');
                updateOllieStatus('Niet verbonden', 'disconnected');
                this.device = null;
            }

            async init() {
                console.log('Initializing Ollie...');
                const useAntiDos = this.characteristics['22bb746f-2bbf-7554-2d6f-726568705327'];
                await useAntiDos.writeValue(new TextEncoder().encode('011i3'));
                await this.wake();
            }

            getNextSequence() {
                this.sequence = (this.sequence + 1) % 256;
                return this.sequence;
            }
            
            async sendCommand(did, cid, data = []) {
                if (!this.device || !this.device.gatt.connected) {
                    console.warn('Cannot send command, Ollie not connected.');
                    return;
                }
                const sequence = this.getNextSequence();
                const dataLength = data.length + 1;
                const checksum = (~((did + cid + sequence + dataLength + data.reduce((a, b) => a + b, 0)) & 0xFF)) & 0xFF;
                const command = new Uint8Array([0xFF, 0xFF, did, cid, sequence, dataLength, ...data, checksum]);
                try {
                    await this.characteristics['22bb746f-2bb2-7554-2d6f-726568705327'].writeValue(command);
                } catch (error) {
                    console.error('Error sending command:', error);
                }
            }

            async wake() {
                console.log('Waking Ollie...');
                await this.sendCommand(0x02, 0x13, [0x01]);
            }

            async setColor(r, g, b) {
                console.log(`Setting color to rgb(${r}, ${g}, ${b})`);
                await this.sendCommand(0x02, 0x20, [r, g, b, 0x01]);
            }
            
            async drive(speed, heading, state = 1) {
                this.currentHeading = heading; // Store current heading
                let clampedSpeed = Math.max(0, Math.min(255, speed));
                let clampedHeading = Math.round(heading % 360);
                const headingHigh = clampedHeading >> 8;
                const headingLow = clampedHeading & 0xFF;
                await this.sendCommand(0x02, 0x30, [clampedSpeed, headingHigh, headingLow, state]);
            }

            async setRawMotors(leftMode, leftSpeed, rightMode, rightSpeed) {
                await this.sendCommand(0x02, 0x33, [leftMode, leftSpeed, rightMode, rightSpeed]);
            }
        }
        
        // --- Main Application Logic ---

        const ollie = new Ollie();
        let gamepadIndex = null;
        let isDriving = false;
        let previousButtonStates = [];
        
        // --- New state variables ---
        let maxSpeed = 1.0; // 100%
        let isTrickMode = false;
        let currentColor = { r: 0, g: 191, b: 255 }; // Default blue

        function updateOllieStatus(text, statusClass) {
            ollieStatus.textContent = `Ollie: ${text}`;
            ollieStatusDot.className = `status-dot ${statusClass}`;
        }
        
        function updateGamepadStatus(text, statusClass) {
            gamepadStatus.textContent = `Gamepad: ${text}`;
            gamepadStatusDot.className = `status-dot ${statusClass}`;
        }

        // --- On-screen Joystick Setup ---
        const joystickManager = nipplejs.create({
            zone: joystickZone,
            mode: 'static',
            position: { left: '50%', top: '50%' },
            color: 'white',
            size: 150
        });

        joystickManager.on('move', (evt, data) => {
            if (!ollie.device || gamepadIndex !== null || isTrickMode) return;
            const speed = Math.min(Math.floor(data.distance * 3), 255);
            const heading = Math.round(data.angle.degree);
            ollie.drive(Math.round(speed * maxSpeed), heading);
            isDriving = true;
        });

        joystickManager.on('end', () => {
            if (!ollie.device || !isDriving) return;
            ollie.drive(0, 0); // Stop
            isDriving = false;
        });
        
        // --- Gamepad API Logic ---
        window.addEventListener('gamepadconnected', (e) => {
            console.log('Gamepad connected:', e.gamepad.id);
            gamepadIndex = e.gamepad.index;
            updateGamepadStatus('Verbonden', 'connected');
            previousButtonStates = e.gamepad.buttons.map(b => b.pressed);
            gameLoop();
        });

        window.addEventListener('gamepaddisconnected', (e) => {
            console.log('Gamepad disconnected:', e.gamepad.id);
            if (gamepadIndex === e.gamepad.index) {
                gamepadIndex = null;
                updateGamepadStatus('Niet verbonden', 'disconnected');
            }
        });
        
        function changeMaxSpeed(amount) {
            maxSpeed += amount;
            maxSpeed = Math.max(0.1, Math.min(1.0, maxSpeed)); // Clamp between 10% and 100%
            speedIndicator.textContent = `Max Snelheid: ${Math.round(maxSpeed * 100)}%`;
            // Re-apply color to adjust brightness
            applyColor(currentColor.r, currentColor.g, currentColor.b, true);
        }

        function applyColor(r, g, b, internalCall = false) {
             if (!ollie.device) return;
            currentColor = {r, g, b};
            const brightR = Math.round(r * maxSpeed);
            const brightG = Math.round(g * maxSpeed);
            const brightB = Math.round(b * maxSpeed);
            ollie.setColor(brightR, brightG, brightB);

            if (!internalCall) {
                // Update color picker UI if changed by gamepad
                const toHex = c => ('0'+(c).toString(16)).slice(-2);
                colorPicker.value = `#${toHex(r)}${toHex(g)}${toHex(b)}`;
            }
        }
        
        function updateModeIndicator() {
             modeIndicator.textContent = `Modus: ${isTrickMode ? 'Trick' : 'Normaal'}`;
             modeIndicator.className = `w-48 text-center p-2 rounded-lg font-medium ${isTrickMode ? 'bg-purple-600' : 'bg-indigo-600'}`;
        }
        
        async function doTrick(trickName) {
            if (!ollie.device) return;
            switch(trickName) {
                case 'spinLeft':
                    await ollie.setRawMotors(2, 200, 1, 200); // left reverse, right forward
                    setTimeout(() => ollie.setRawMotors(0, 0, 0, 0), 500);
                    break;
                case 'spinRight':
                    await ollie.setRawMotors(1, 200, 2, 200); // left forward, right reverse
                    setTimeout(() => ollie.setRawMotors(0, 0, 0, 0), 500);
                    break;
                case 'flipForward':
                    await ollie.drive(255, ollie.currentHeading);
                    setTimeout(() => ollie.drive(0, ollie.currentHeading), 300);
                    break;
                case 'flipBackward':
                    // Drive backwards: speed, (heading + 180) % 360
                    const backHeading = (ollie.currentHeading + 180) % 360;
                    await ollie.drive(255, backHeading);
                    setTimeout(() => ollie.drive(0, backHeading), 300);
                    break;
            }
        }

        function gameLoop() {
            if (gamepadIndex === null) return;
            
            const gp = navigator.getGamepads()[gamepadIndex];
            if (!gp) return;

            const currentButtonStates = gp.buttons.map(b => b.pressed);

            // -- Mode Toggle --
            const comboPressed = currentButtonStates[4] && currentButtonStates[5]; // LB + RB
            const prevComboPressed = previousButtonStates[4] && previousButtonStates[5];
            if (comboPressed && !prevComboPressed) {
                isTrickMode = !isTrickMode;
                updateModeIndicator();
            }

            if (isTrickMode) {
                // -- Trick Mode Logic --
                if (currentButtonStates[0] && !previousButtonStates[0]) doTrick('spinLeft');
                if (currentButtonStates[1] && !previousButtonStates[1]) doTrick('flipForward');
                if (currentButtonStates[2] && !previousButtonStates[2]) doTrick('flipBackward');
                if (currentButtonStates[3] && !previousButtonStates[3]) doTrick('spinRight');

            } else {
                // -- Normal Mode Logic --
                // Speed Control
                if (currentButtonStates[4] && !previousButtonStates[4]) changeMaxSpeed(-0.1); // LB
                if (currentButtonStates[5] && !previousButtonStates[5]) changeMaxSpeed(0.1);  // RB
                
                // Color Control
                if (currentButtonStates[0] && !previousButtonStates[0]) applyColor(255, 0, 0);   // A
                if (currentButtonStates[1] && !previousButtonStates[1]) applyColor(0, 0, 255);   // B
                if (currentButtonStates[2] && !previousButtonStates[2]) applyColor(0, 255, 0);   // X
                if (currentButtonStates[3] && !previousButtonStates[3]) applyColor(255, 255, 0); // Y

                // Driving with Joystick
                const x = gp.axes[0];
                const y = -gp.axes[1];
                const deadzone = 0.15;
                const magnitude = Math.sqrt(x * x + y * y);

                if (magnitude > deadzone) {
                    isDriving = true;
                    const speed = Math.min(Math.floor(((magnitude - deadzone) / (1 - deadzone)) * 255), 255);
                    let heading = Math.atan2(x, y) * (180 / Math.PI);
                    if (heading < 0) heading += 360;
                    
                    if (ollie.device) {
                        ollie.drive(Math.round(speed * maxSpeed), heading);
                    }
                } else if (isDriving) {
                    if (ollie.device) ollie.drive(0, 0);
                    isDriving = false;
                }
            }

            previousButtonStates = currentButtonStates;
            requestAnimationFrame(gameLoop);
        }

        // --- Event Listeners ---
        connectButton.addEventListener('click', async () => {
            if (ollie.device) {
                ollie.device.gatt.disconnect();
            } else {
                await ollie.connect();
            }
        });

        colorPicker.addEventListener('input', (event) => {
            const hex = event.target.value;
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            applyColor(r, g, b);
        });

    </script>
</body>
</html>


